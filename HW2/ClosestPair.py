# -*- coding: utf-8 -*-
import math
import random
import time


#求取两点间欧式距离
def distance((a,b),(c,d)):
    return math.sqrt((a-c)*(a-c)+(b-d)*(b-d))

#生成n个点对
nodes = []
#n = 500

'''
for i in range(0,n):
    nodes.append((random.uniform(-1000,1000),random.uniform(-1000,1000)))
    #nodes.append((random.randint(0, 1000), random.randint(0, 1000)))
    '''

#nodes = [(544, 317), (420, 788), (87, 311), (536, 738), (351, 548), (458, 395), (822, 132), (665, 11), (793, 623), (721, 403), (878, 856), (59, 490), (316, 133), (171, 524), (794, 874), (982, 634), (875, 121), (779, 13), (247, 97), (891, 674), (689, 14), (623, 665), (585, 620), (858, 856), (438, 614), (374, 926), (644, 734), (504, 235), (833, 107), (661, 931), (61, 524), (496, 334), (145, 491), (643, 576), (725, 688), (853, 757), (474, 731), (701, 493), (538, 215), (857, 462), (716, 601), (514, 476), (870, 673), (167, 810), (831, 645), (901, 125), (49, 746), (166, 274), (894, 138)]
nodes = [(120.26, 77.48), (743.18, 790.48), (460.95, 562.84), (535.4, 53.41), (316.69, 453.51), (311.93, 709.01), (367.01, 273.11), (354.42, 301.92), (441.11, 705.7), (758.88, 675.41), (113.8, 576.39), (387.52, 753.42), (481.03, 265.03), (471.22, 700.95), (348.59, 33.11), (54.39, 511.16), (506.47, 79.08), (706.66, 773.63), (522.21, 207.05), (162.44, 615.23), (684.7, 145.12), (381.25, 135.13), (68.56, 412.7), (256.64, 228.27), (444.14, 168.25), (219.71, 412.73), (237.86, 120.61), (632.73, 677.89), (343.47, 694.82), (213.7, 258.45), (106.23, 319.73), (245.97, 705.0), (244.08, 432.65), (338.1, 162.4), (31.03, 261.82), (606.33, 61.54), (476.31, 206.91), (763.79, 76.54), (582.93, 604.42), (587.2, 473.17), (227.67, 475.93), (92.24, 222.01), (464.83, 771.19), (213.2, 362.01), (153.23, 189.31), (793.84, 41.94), (161.77, 45.49), (542.41, 643.79), (431.21, 414.92), (551.62, 417.8), (118.6, 174.2), (752.32, 537.63), (550.85, 198.83), (437.69, 639.89), (636.56, 798.29), (785.02, 560.12), (65.08, 38.46), (97.38, 96.58), (58.94, 82.92), (353.83, 400.12), (123.59, 669.75), (728.49, 82.97), (565.46, 325.3), (131.75, 65.94), (221.25, 445.18), (232.28, 475.29), (623.08, 788.76), (111.25, 49.94), (342.81, 138.73), (621.01, 381.62), (703.32, 101.36), (753.86, 491.97), (42.87, 458.99), (369.98, 449.67), (696.34, 48.32), (512.09, 464.99), (432.93, 487.06), (41.29, 503.04), (281.24, 637.7), (266.52, 31.77), (709.28, 177.88), (506.78, 559.06), (626.29, 304.78), (664.02, 223.79), (744.29, 787.33), (452.4, 735.01), (622.0, 246.58), (529.5, 505.06), (48.99, 368.76), (563.42, 748.66), (302.78, 278.33), (414.43, 197.95), (739.08, 447.46), (450.63, 575.18), (136.0, 89.91), (398.37, 343.66), (569.09, 166.5), (788.66, 410.76), (410.02, 710.03), (730.84, 82.65), (719.0, 154.93), (708.94, 121.47), (297.67, 473.92), (681.08, 634.61), (563.85, 178.6), (390.56, 578.71), (272.25, 574.06), (205.95, 25.45), (681.3, 491.79), (492.11, 610.87), (797.74, 177.61), (723.5, 206.55), (66.63, 264.22), (175.07, 422.71), (195.35, 550.69), (19.4, 560.03), (739.11, 273.43), (539.48, 155.74), (6.35, 396.31), (758.99, 565.19), (97.42, 300.53), (82.02, 112.2), (306.16, 265.01)]
n = len(nodes)
print len(nodes)

#暴力算法找最近点对
def brute_cp(nodes,n):
    result = [(0, 0), (0, 0), 3000]
    for i in range(0, n):
        if i % 1000 == 0:
            print i
        for j in range(i + 1, n):
            dis = distance(nodes[i], nodes[j])
            if dis < result[2]:
                result = [nodes[i], nodes[j], dis]
    return result

#用分治法找最近点对
def divide_cp(nodes,n):
    result = [(0, 0), (0, 0), 1500]
    if n < 2:
        return result
    if n == 2:
        dis = distance(nodes[0], nodes[1])
        return [nodes[0], nodes[1], dis]
    x_nodes = sorted(nodes,key = lambda x:x[0])
    if n%2 == 0:
        m = (x_nodes[n/2][0] + x_nodes[n/2-1][0])/2
    else:
        m = x_nodes[n/2][0]
    result1 = divide_cp(x_nodes[0:n/2],len(x_nodes[0:n/2]))
    result2 = divide_cp(x_nodes[n/2:n],len(x_nodes[n/2 :n]))
    d = min(result1[2],result2[2])
    if result1[2] <= result2[2]:
        result = result1
    else:
        result = result2
    temp = filter(lambda x:m+d > x[0] > m-d,nodes)
    m_nodes = sorted(temp,key = lambda x:x[1])
    for i in range(0,len(m_nodes)):
        j = i + 1
        while j < i+8 and j < len(m_nodes):
            dis = distance(m_nodes[i],m_nodes[j])
            if dis < result[2]:
                result = [m_nodes[i],m_nodes[j],dis]
            j +=1
    return result

t0 = time.clock()
r1 = brute_cp(nodes,n)
t1 = time.clock()
print ("Total time running brute_cp(%s) : %s seconds" %
           (str(n),  str(t1 - t0))
           )
t0 = time.clock()
r2 = divide_cp(nodes,n)
t1 = time.clock()
print ("Total time running brute_cp(%s) : %s seconds" %
           (str(n),  str(t1 - t0))
           )
print "brute_cp: ", r1
print "divide_cp: ", r2
print r1[2] - r2[2]
print nodes



